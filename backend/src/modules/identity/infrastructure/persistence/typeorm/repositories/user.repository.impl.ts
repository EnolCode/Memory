import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { IUserRepository } from '../../../../domain/repositories/user.repository.interface';
import { User } from '../../../../domain/entities/user.entity';
import { UserSchema } from '../entities/user.schema';

@Injectable()
export class UserRepositoryImpl implements IUserRepository {
  constructor(
    @InjectRepository(UserSchema)
    private readonly userRepository: Repository<UserSchema>,
  ) {}

  async findById(id: string): Promise<User | null> {
    const userSchema = await this.userRepository.findOne({
      where: { id },
    });

    if (!userSchema) return null;

    return this.toDomainEntity(userSchema);
  }

  async findByEmail(email: string): Promise<User | null> {
    const userSchema = await this.userRepository.findOne({
      where: { email },
    });

    if (!userSchema) return null;

    return this.toDomainEntity(userSchema);
  }

  async save(user: User): Promise<User> {
    const userSchema = this.toPersistence(user);
    const savedUser = await this.userRepository.save(userSchema);
    return this.toDomainEntity(savedUser);
  }

  async update(id: string, data: Partial<{ hashedRefreshToken: string }>): Promise<void> {
    await this.userRepository.update(id, data);
  }

  create(userData: { email: string; password: string; username?: string }): User {
    const id = ''; // Will be generated by database
    return new User(
      id,
      userData.email,
      userData.username || null,
      userData.password,
      new Date(),
      new Date(),
    );
  }

  private toDomainEntity(userSchema: UserSchema): User {
    const user = new User(
      userSchema.id,
      userSchema.email,
      userSchema.username,
      userSchema.password,
      userSchema.createdAt,
      userSchema.updatedAt,
    );

    // Set the refresh token if exists
    if (userSchema.hashedRefreshToken) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
      (user as any).hashedRefreshToken = userSchema.hashedRefreshToken;
    }

    return user;
  }

  private toPersistence(user: User): Partial<UserSchema> {
    return {
      id: user.getId() || undefined,
      email: user.getEmail(),
      username: user.getUsername() || undefined,
      password: user.getPassword(),
      hashedRefreshToken: user.getHashedRefreshToken(),
      createdAt: user.getCreatedAt(),
      updatedAt: user.getUpdatedAt(),
    };
  }
}
